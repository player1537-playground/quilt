<!DOCTYPE html>
<title>quilt</title>
<style>
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}
</style>
<body>
<script src="https://rawcdn.githack.com/mrdoob/three.js/954e0e738cfb813357ce57b49b254366134b5b3a/build/three.min.js"></script>
<script src="https://rawcdn.githack.com/mrdoob/three.js/954e0e738cfb813357ce57b49b254366134b5b3a/examples/js/controls/OrbitControls.js"></script>
<script>
THREE.OSPAttributes = function() {
	var buffers = new WeakMap();

	async function createBuffer( attribute ) {
		var array = attribute.array;

		if ( array instanceof Uint16Array ) {
			var newArray = new Uint32Array( array.length );
			for ( var i = 0, l = array.length; i < l; ++i ) {
				newArray[i] = array[i];
			}
			array = newArray;
		}

		var url = '/buffer/';
		var params = {
			method: 'POST',
			body: array,
		};

		var response = await fetch( url, params );
		var id = await response.text();

		return {
			id: id,
			version: attribute.version
		};
	}

	async function updateBuffer( data, attribute ) {
		data = await createBuffer( attribute );
		buffers.set( attribute, data );
	}

	function get( attribute ) {
		return buffers.get( attribute );
	}

	function remove( attribute ) {
		var data = buffers.get( attribute );
		if ( data ) {
			buffers.delete( data );
		}
	}

	async function update( attribute ) {
		var data = buffers.get( attribute );
		if (data === undefined ) {
			data = await createBuffer( attribute );
			buffers.set( attribute, data );
		} else if ( data.version < attribute.version ) {
			await updateBuffer( data, attribute );
			data.version = attribute.version;
		}
		return data;
	}

	return {
		get: get,
		remove: remove,
		update: update
	};
};

THREE.OSPRenderer = function ( numColumns ) {
	if ( numColumns === undefined ) {
		numColumns = 1;
	}

	var attributes = new THREE.OSPAttributes();

	var domElement = document.createElement( 'div' );
	var imageElements = [];
	var worldPosition = new THREE.Vector3();
	var worldDirection = new THREE.Vector3();
	var worldUp = new THREE.Vector3();
	var _quality = 512;
	var _size = _quality;
	var _numColumns = numColumns;

	var resetDomElement = function() {
		while ( domElement.firstChild ) {
			domElement.removeChild( domElement.firstChild );
		}

		domElement.style.width = _size + 'px';
		domElement.style.height = _size + 'px';

		imageElements = [];
		var image;
		for ( let i = 0; i < _numColumns; ++i ) {
			for ( let j = 0; j < _numColumns; ++j ) {
				image = document.createElement( 'img' );
				image.style.width = ( _size / _numColumns ) + 'px';
				image.style.height = ( _size / _numColumns ) + 'px';
				image.style.float = 'left';
				domElement.appendChild( image );
				imageElements.push( image );
			}
		}
	};

	resetDomElement();
	this.domElement = domElement;

	this.setQuality = function ( quality ) {
		_quality = quality;
		resetDomElement();
	};

	this.setSize = function ( width, height ) {
		if ( height === undefined ) {
			height = width;
		}

		if ( width !== height ) {
			console.error( 'Expected same width and height' );
			width = Math.max( width, height );
		}
		_size = width;
		resetDomElement();
	};

	this.setColumns = function ( numColumns ) {
		_numColumns = numColumns;
		resetDomElement();
	};

	var encodeGeometry = async function ( object, geometry, parts ) {
		if ( geometry.type === 'SphereGeometry' || geometry.type === 'SphereBufferGeometry' ) {
			object.getWorldPosition( worldPosition );
			parts.push( 'sphere' );
			parts.push( worldPosition.x, worldPosition.y, worldPosition.z, geometry.parameters.radius );
		} else if ( geometry.type === 'TorusBufferGeometry' ) {
			parts.push( 'triangles' );
			var triverts = await attributes.update( geometry.getAttribute( 'position' ) );
			var trinorms = await attributes.update( geometry.getAttribute( 'normal' ) );
			var triuv = await attributes.update( geometry.getAttribute( 'uv' ) );
			var triindex = await attributes.update( geometry.getIndex() );
			parts.push( triverts.id, trinorms.id, triuv.id, triindex.id );
		} else {
			throw 'Unknown geometry: ' + geometry.type;
		}
	};

	var encodeMaterial = async function ( object, material, parts ) {
		if ( material.type === 'MeshBasicMaterial' ) {
			if ( material.color && !material.map ) {
				parts.push( material.color.r, material.color.g, material.color.b );
				return;
			}
		}

		throw 'Unknown material: ' + material.type;
	};

	var encodeObject = async function ( object, parts ) {
		if ( object.type === 'Mesh' ) {
			await encodeGeometry( object, object.geometry, parts );
			await encodeMaterial( object, object.material, parts );
		}

		for ( var i = 0, l = object.children.length; i < l; ++i ) {
			await encodeObject( object.children[ i ], parts );
		}
	};

	var encodeScene = async function ( scene ) {
		var parts = ['scene'];
		await encodeObject( scene, parts );
		return parts.join(',');
	};

	var encodeCamera = async function ( camera ) {
		camera.getWorldDirection( worldDirection );
		camera.getWorldPosition( worldPosition );
		worldUp.set( 0, 1, 0 );

		var parts = [
			worldPosition.x, worldPosition.y, worldPosition.z,
			worldUp.x, worldUp.y, worldUp.z,
			worldDirection.x, worldDirection.y, worldDirection.z,
		];
		
		return parts.join('/');
	};

	var loadImage = function ( url, image ) {
		if ( image === undefined ) {
			image = document.createElement( 'img' );
		}

		return new Promise( function ( resolve, reject ) {
			image.onload = resolve;
			image.onerror = reject;
			image.src = url;
		});
	}

	var asyncRenderPromise = null;

	var asyncRender = async function ( scene, camera ) {
		var numTiles = _numColumns * _numColumns;

		var parts = [
			'image',
			await encodeScene( scene ),
			await encodeCamera( camera ),
			_quality,
		];

		var promises = [];
		for ( let i = 0; i < numTiles; ++i ) {
			var url = parts.join('/') + '/tiling,' + i + '-' + numTiles;
			var promise = loadImage( url, imageElements[ i ] );
			promises.push( promise );
		}
		
		return Promise.all( promises );
	};

	var afterRender = function() {
		asyncRenderPromise = null;
	};

	this.render = function ( scene, camera ) {
		if (asyncRenderPromise !== null) {
			return false;
		}

		asyncRenderPromise = asyncRender( scene, camera ).then( afterRender );

		return true;
	};
};
</script>
<script>
const quality = 64;
const numColumns = 1;
const width = height = 256;

const renderer = new THREE.OSPRenderer(numColumns);
renderer.setSize(width, height);
renderer.setQuality(quality);
document.body.appendChild(renderer.domElement);

const camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 0.01, 10000);
camera.position.set(0, 0, 1);

const controls = new THREE.OrbitControls(camera, renderer.domElement);

const scene = new THREE.Scene();

const geometry = new THREE.TorusBufferGeometry(8/10/2, 2.8/10/2, 6, 10);
const material = new THREE.MeshBasicMaterial({ color: 0xff00ff });
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

step();
function step() {
	requestAnimationFrame(step);
	controls.update();
	renderer.render(scene, camera);
}
</script>
