<!DOCTYPE html>
<title>quilt</title>
<style>
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}
</style>
<body>
<script src="https://rawcdn.githack.com/mrdoob/three.js/954e0e738cfb813357ce57b49b254366134b5b3a/build/three.min.js"></script>
<script src="https://rawcdn.githack.com/mrdoob/three.js/954e0e738cfb813357ce57b49b254366134b5b3a/examples/js/controls/OrbitControls.js"></script>
<script>
THREE.OSPRenderer = function ( numColumns ) {
	if ( numColumns === undefined ) {
		numColumns = 1;
	}

	var domElement = document.createElement( 'div' );
	var imageElements = [];
	var worldPosition = new THREE.Vector3();
	var worldDirection = new THREE.Vector3();
	var worldUp = new THREE.Vector3();
	var _quality = 512;
	var _size = _quality;
	var _numColumns = numColumns;

	var resetDomElement = function() {
		while ( domElement.firstChild ) {
			domElement.removeChild( domElement.firstChild );
		}

		domElement.style.width = _size + 'px';
		domElement.style.height = _size + 'px';

		imageElements = [];
		var image;
		for ( let i = 0; i < _numColumns; ++i ) {
			for ( let j = 0; j < _numColumns; ++j ) {
				image = document.createElement( 'img' );
				image.style.width = ( _size / _numColumns ) + 'px';
				image.style.height = ( _size / _numColumns ) + 'px';
				image.style.float = 'left';
				domElement.appendChild( image );
				imageElements.push( image );
			}
		}
	};

	resetDomElement();
	this.domElement = domElement;

	this.setQuality = function ( quality ) {
		_quality = quality;
		resetDomElement();
	};

	this.setSize = function ( width, height ) {
		if ( height === undefined ) {
			height = width;
		}

		if ( width !== height ) {
			console.error( 'Expected same width and height' );
			width = Math.max( width, height );
		}
		_size = width;
		resetDomElement();
	};

	this.setColumns = function ( numColumns ) {
		_numColumns = numColumns;
		resetDomElement();
	};

	var encodeGeometry = function ( object, geometry, parts ) {
		if ( geometry.type === 'SphereGeometry' || geometry.type === 'SphereBufferGeometry' ) {
			object.getWorldPosition( worldPosition );
			parts.push( 'sphere' );
			parts.push( worldPosition.x, worldPosition.y, worldPosition.z, geometry.parameters.radius );
			return;
		}

		throw 'Unknown geometry: ' + geometry.type;
	};

	var encodeMaterial = function ( object, material, parts ) {
		if ( material.type === 'MeshBasicMaterial' ) {
			if ( material.color && !material.map ) {
				parts.push( material.color.r, material.color.g, material.color.b );
				return;
			}
		}

		throw 'Unknown material: ' + material.type;
	};

	var encodeObject = function ( object, parts ) {
		if ( object.type === 'Mesh' ) {
			encodeGeometry( object, object.geometry, parts );
			encodeMaterial( object, object.material, parts );
		}

		for ( var i = 0, l = object.children.length; i < l; ++i ) {
			encodeObject( object.children[ i ], parts );
		}
	};

	var encodeScene = function ( scene ) {
		var parts = ['scene'];
		encodeObject( scene, parts );
		return parts.join(',');
	};

	var encodeCamera = function ( camera ) {
		camera.getWorldDirection( worldDirection );
		camera.getWorldPosition( worldPosition );
		worldUp.set( 0, 1, 0 );

		var parts = [
			worldPosition.x, worldPosition.y, worldPosition.z,
			worldUp.x, worldUp.y, worldUp.z,
			worldDirection.x, worldDirection.y, worldDirection.z,
		];
		
		return parts.join('/');
	};

	var loadImage = function ( url, image ) {
		if ( image === undefined ) {
			image = document.createElement( 'img' );
		}

		return new Promise( function ( resolve, reject ) {
			image.onload = resolve;
			image.onerror = reject;
			image.src = url;
		});
	}

	var asyncRenderPromise = null;

	var asyncRender = async function ( scene, camera ) {
		var numTiles = _numColumns * _numColumns;

		var parts = [
			'image',
			encodeScene( scene ),
			encodeCamera( camera ),
			_quality,
		];

		var promises = [];
		for ( let i = 0; i < numTiles; ++i ) {
			var url = parts.join('/') + '/tiling,' + i + '-' + numTiles;
			var promise = loadImage( url, imageElements[ i ] );
			promises.push( promise );
		}
		
		return Promise.all( promises );
	};

	var afterRender = function() {
		asyncRenderPromise = null;
	};

	this.render = function ( scene, camera ) {
		if (asyncRenderPromise !== null) {
			return false;
		}

		asyncRenderPromise = asyncRender( scene, camera ).then( afterRender );

		return true;
	};
};
</script>
<script>
const quality = 64;
const numColumns = 1;
const width = height = 256;

const renderer = new THREE.OSPRenderer(numColumns);
renderer.setSize(width, height);
renderer.setQuality(quality);
document.body.appendChild(renderer.domElement);

const camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 0.01, 10000);
camera.position.set(0, 0, 1);

const controls = new THREE.OrbitControls(camera, renderer.domElement);

const scene = new THREE.Scene();

for (let i=0; i<10; i+=3)
for (let j=0; j<10; j+=3)
for (let k=0; k<10; k+=3) {
	const geometry = new THREE.SphereBufferGeometry(0.05);
	const material = new THREE.MeshBasicMaterial({ color: new THREE.Color(i / 10, j / 10, k / 10), side: THREE.DoubleSide });
	const mesh = new THREE.Mesh(geometry, material);
	mesh.position.set((i-5)/10, (j-5)/10, (k-5)/10);
	scene.add(mesh);
}

step();
function step() {
	requestAnimationFrame(step);
	controls.update();
	renderer.render(scene, camera);
}
</script>
